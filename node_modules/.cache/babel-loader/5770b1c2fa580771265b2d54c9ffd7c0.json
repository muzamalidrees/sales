{"ast":null,"code":"import React, { Fragment, createElement, PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { Ability } from '@casl/ability';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar noop = function noop() {};\n\nvar _renderChildren = Fragment ? function (children) {\n  return createElement.apply(null, [Fragment, null].concat(children));\n} : React.Children.only;\n\nvar propTypes = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  var REQUIRED_OBJECT_OR_STRING = PropTypes.oneOfType([PropTypes.object, PropTypes.string]).isRequired;\n\n  var alias = function alias(names, validate) {\n    return function (props) {\n      // eslint-disable-line\n      if (!names.split(' ').some(function (name) {\n        return props[name];\n      })) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return validate.apply(void 0, [props].concat(args));\n      }\n    };\n  };\n\n  propTypes = {\n    I: alias('do', PropTypes.string.isRequired),\n    a: alias('on this of an', REQUIRED_OBJECT_OR_STRING),\n    an: alias('on this of a', REQUIRED_OBJECT_OR_STRING),\n    of: alias('on a this an', REQUIRED_OBJECT_OR_STRING),\n    this: alias('on a of an', REQUIRED_OBJECT_OR_STRING),\n    do: alias('I', PropTypes.string.isRequired),\n    on: alias('this a of an', REQUIRED_OBJECT_OR_STRING),\n    not: PropTypes.bool,\n    passThrough: PropTypes.bool,\n    children: PropTypes.any.isRequired,\n    ability: PropTypes.instanceOf(Ability).isRequired\n  };\n}\n\nvar Can =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inheritsLoose(Can, _PureComponent);\n\n  function Can() {\n    var _this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this = _PureComponent.call.apply(_PureComponent, [this].concat(args)) || this;\n    _this.unsubscribeFromAbility = noop;\n    _this._isAllowed = false;\n    _this._ability = null;\n    return _this;\n  }\n\n  var _proto = Can.prototype;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unsubscribeFromAbility();\n  };\n\n  _proto.connectToAbility = function connectToAbility(ability) {\n    var _this2 = this;\n\n    if (ability === this._ability) {\n      return;\n    }\n\n    this.unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this.unsubscribeFromAbility = ability.on('updated', function () {\n        return _this2.forceUpdate();\n      });\n    }\n  };\n\n  _proto.isAllowed = function isAllowed() {\n    var params = this.props;\n\n    var _split = (params.I || params.do).split(/\\s+/),\n        action = _split[0],\n        field = _split[1];\n\n    var subject = params.of || params.a || params.an || params.this || params.on;\n    var can = params.not ? 'cannot' : 'can';\n    return params.ability[can](action, subject, field);\n  };\n\n  _proto.render = function render() {\n    this.connectToAbility(this.props.ability);\n    this._isAllowed = this.isAllowed();\n    return this.props.passThrough || this._isAllowed ? this.renderChildren() : null;\n  };\n\n  _proto.renderChildren = function renderChildren() {\n    var _this$props = this.props,\n        children = _this$props.children,\n        ability = _this$props.ability;\n    var elements = typeof children === 'function' ? children(this._isAllowed, ability) : children;\n    return _renderChildren(elements);\n  };\n\n  _createClass(Can, [{\n    key: \"allowed\",\n    get: function get() {\n      return this._isAllowed;\n    }\n  }]);\n\n  return Can;\n}(PureComponent);\n\n_defineProperty(Can, \"propTypes\", propTypes);\n\nfunction createCanBoundTo(ability) {\n  var _class, _temp;\n\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_Can) {\n    _inheritsLoose(BoundCan, _Can);\n\n    function BoundCan() {\n      return _Can.apply(this, arguments) || this;\n    }\n\n    return BoundCan;\n  }(Can), _defineProperty(_class, \"propTypes\", Object.assign({}, Can.propTypes, {\n    ability: PropTypes.instanceOf(Ability)\n  })), _defineProperty(_class, \"defaultProps\", {\n    ability: ability\n  }), _temp;\n}\n\nfunction createContextualCan(Consumer) {\n  return function ContextualCan(props) {\n    return createElement(Consumer, null, function (ability) {\n      return createElement(Can, {\n        ability: props.ability || ability,\n        I: props.I || props.do,\n        a: props.on || props.a || props.an || props.of || props.this,\n        not: props.not,\n        children: props.children,\n        passThrough: props.passThrough\n      });\n    });\n  };\n}\n\nexport { Can, createCanBoundTo, createContextualCan };","map":null,"metadata":{},"sourceType":"module"}