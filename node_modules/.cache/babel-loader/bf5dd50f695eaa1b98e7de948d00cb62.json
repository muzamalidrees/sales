{"ast":null,"code":"import sift from 'sift';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction ForbiddenError(message, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  Error.call(this);\n  this.constructor = ForbiddenError;\n  this.subject = options.subject;\n  this.subjectName = options.subjectName;\n  this.action = options.action;\n  this.field = options.field;\n  this.message = message || \"Cannot execute \\\"\" + this.action + \"\\\" on \\\"\" + this.subjectName + \"\\\"\";\n\n  if (typeof Error.captureStackTrace === 'function') {\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = new Error(this.message).stack;\n  }\n}\n\nForbiddenError.prototype = Object.create(Error.prototype);\n\nfunction wrapArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction getSubjectName(subject) {\n  if (!subject || typeof subject === 'string') {\n    return subject;\n  }\n\n  var Type = typeof subject === 'object' ? subject.constructor : subject;\n  return Type.modelName || Type.name;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar Rule =\n/*#__PURE__*/\nfunction () {\n  function Rule(params) {\n    this.actions = params.actions || params.action;\n    this.subject = params.subject;\n    this.fields = !params.fields || params.fields.length === 0 ? undefined : wrapArray(params.fields);\n    this.inverted = !!params.inverted;\n    this.conditions = params.conditions;\n    this._matches = this.conditions ? sift(this.conditions) : undefined;\n    this.reason = params.reason;\n  }\n\n  var _proto = Rule.prototype;\n\n  _proto.matches = function matches(object) {\n    if (!this._matches) {\n      return true;\n    }\n\n    if (typeof object === 'string') {\n      return !this.inverted;\n    }\n\n    return this._matches(object);\n  };\n\n  _proto.isRelevantFor = function isRelevantFor(object, field) {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    return this.fields.indexOf(field) !== -1;\n  };\n\n  return Rule;\n}();\n\nvar PRIVATE_FIELD = typeof Symbol !== 'undefined' ? Symbol('private') : \"__\" + Date.now();\nvar DEFAULT_ALIASES = {\n  crud: ['create', 'read', 'update', 'delete']\n};\n\nfunction hasAction(action, actions) {\n  return action === actions || Array.isArray(actions) && actions.indexOf(action) !== -1;\n}\n\nvar Ability =\n/*#__PURE__*/\nfunction () {\n  Ability.addAlias = function addAlias(alias, actions) {\n    if (alias === 'manage' || hasAction('manage', actions)) {\n      throw new Error('Cannot add alias for \"manage\" action because it represents any action');\n    }\n\n    if (hasAction(alias, actions)) {\n      throw new Error(\"Attempt to alias action to itself: \" + alias + \" -> \" + actions.toString());\n    }\n\n    DEFAULT_ALIASES[alias] = actions;\n    return this;\n  };\n\n  function Ability(rules, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$RuleType = _ref.RuleType,\n        RuleType = _ref$RuleType === void 0 ? Rule : _ref$RuleType,\n        _ref$subjectName = _ref.subjectName,\n        subjectName = _ref$subjectName === void 0 ? getSubjectName : _ref$subjectName;\n\n    this[PRIVATE_FIELD] = {\n      RuleType: RuleType,\n      subjectName: subjectName,\n      originalRules: rules || [],\n      indexedRules: Object.create(null),\n      mergedRules: Object.create(null),\n      events: {},\n      aliases: clone(DEFAULT_ALIASES)\n    };\n    this.update(rules);\n  }\n\n  var _proto = Ability.prototype;\n\n  _proto.update = function update(rules) {\n    if (Array.isArray(rules)) {\n      var payload = {\n        rules: rules,\n        ability: this\n      };\n      this.emit('update', payload);\n      this[PRIVATE_FIELD].originalRules = Object.freeze(rules.slice(0));\n      this[PRIVATE_FIELD].indexedRules = this.buildIndexFor(rules);\n      this[PRIVATE_FIELD].mergedRules = Object.create(null);\n      this.emit('updated', payload);\n    }\n\n    return this;\n  };\n\n  _proto.buildIndexFor = function buildIndexFor(rules) {\n    var indexedRules = Object.create(null);\n    var RuleType = this[PRIVATE_FIELD].RuleType;\n    var isAllInverted = true;\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = new RuleType(rules[i]);\n      var actions = this.expandActions(rule.actions);\n      var subjects = wrapArray(rule.subject);\n      var priority = rules.length - i - 1;\n      isAllInverted = !!(isAllInverted && rule.inverted);\n\n      for (var k = 0; k < subjects.length; k++) {\n        var subject = subjects[k];\n        indexedRules[subject] = indexedRules[subject] || Object.create(null);\n\n        for (var j = 0; j < actions.length; j++) {\n          var action = actions[j];\n          indexedRules[subject][action] = indexedRules[subject][action] || Object.create(null);\n          indexedRules[subject][action][priority] = rule;\n        }\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production' && isAllInverted && rules.length) {\n      // eslint-disable-next-line\n      console.warn('[casl]: Ability contains only inverted rules. That means user will not be able to do any actions. This will be changed to Error throw in the next major version');\n    }\n\n    return indexedRules;\n  };\n\n  _proto.expandActions = function expandActions(rawActions) {\n    var aliases = this[PRIVATE_FIELD].aliases;\n    var actions = wrapArray(rawActions);\n    var i = 0;\n\n    while (i < actions.length) {\n      var action = actions[i++];\n\n      if (aliases.hasOwnProperty(action)) {\n        actions = actions.concat(aliases[action]);\n      }\n    }\n\n    return actions;\n  };\n\n  _proto.can = function can(action, subject, field) {\n    if (field && typeof field !== 'string') {\n      // eslint-disable-next-line\n      throw new Error('Ability.can expects 3rd parameter to be a string. See https://stalniy.github.io/casl/abilities/2017/07/21/check-abilities.html#checking-fields for details');\n    }\n\n    var rule = this.relevantRuleFor(action, subject, field);\n    return !!rule && !rule.inverted;\n  };\n\n  _proto.relevantRuleFor = function relevantRuleFor(action, subject, field) {\n    var rules = this.rulesFor(action, subject, field);\n\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].matches(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  };\n\n  _proto.possibleRulesFor = function possibleRulesFor(action, subject) {\n    var subjectName = this[PRIVATE_FIELD].subjectName(subject);\n    var mergedRules = this[PRIVATE_FIELD].mergedRules;\n    var key = subjectName + \"_\" + action;\n\n    if (!mergedRules[key]) {\n      mergedRules[key] = this.mergeRulesFor(action, subjectName);\n    }\n\n    return mergedRules[key];\n  };\n\n  _proto.mergeRulesFor = function mergeRulesFor(action, subjectName) {\n    var indexedRules = this[PRIVATE_FIELD].indexedRules;\n    var mergedRules = [subjectName, 'all'].reduce(function (rules, subjectType) {\n      var subjectRules = indexedRules[subjectType];\n\n      if (!subjectRules) {\n        return rules;\n      }\n\n      return Object.assign(rules, subjectRules[action], subjectRules.manage);\n    }, []); // TODO: think whether there is a better to way to prioritize rules\n    // or convert sparse array to regular one\n\n    return mergedRules.filter(Boolean);\n  };\n\n  _proto.rulesFor = function rulesFor(action, subject, field) {\n    // TODO: skip `isRelevantFor` method calls if there are not fields in rules\n    return this.possibleRulesFor(action, subject).filter(function (rule) {\n      return rule.isRelevantFor(subject, field);\n    });\n  };\n\n  _proto.cannot = function cannot() {\n    return !this.can.apply(this, arguments);\n  };\n\n  _proto.throwUnlessCan = function throwUnlessCan() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var rule = this.relevantRuleFor.apply(this, args);\n\n    if (!rule || rule.inverted) {\n      var action = args[0],\n          subject = args[1],\n          field = args[2];\n      var subjectName = this[PRIVATE_FIELD].subjectName(subject);\n      throw new ForbiddenError(rule ? rule.reason : null, {\n        action: action,\n        subjectName: subjectName,\n        subject: subject,\n        field: field\n      });\n    }\n  };\n\n  _proto.on = function on(event, handler) {\n    var events = this[PRIVATE_FIELD].events;\n    var isAttached = true;\n\n    if (!events[event]) {\n      events[event] = [];\n    }\n\n    events[event].push(handler);\n    return function () {\n      if (isAttached) {\n        var index = events[event].indexOf(handler);\n        events[event].splice(index, 1);\n        isAttached = false;\n      }\n    };\n  };\n\n  _proto.emit = function emit(event, payload) {\n    var handlers = this[PRIVATE_FIELD].events[event];\n\n    if (handlers) {\n      handlers.slice(0).forEach(function (handler) {\n        return handler(payload);\n      });\n    }\n  };\n\n  _createClass(Ability, [{\n    key: \"rules\",\n    get: function get() {\n      return this[PRIVATE_FIELD].originalRules;\n    }\n  }]);\n\n  return Ability;\n}();\n\nfunction isStringOrNonEmptyArray(value) {\n  return ![].concat(value).some(function (item) {\n    return typeof item !== 'string';\n  });\n}\n\nfunction isObject(value) {\n  return value && typeof value === 'object';\n}\n\nvar RuleBuilder =\n/*#__PURE__*/\nfunction () {\n  function RuleBuilder(rule) {\n    this.rule = rule;\n  }\n\n  var _proto = RuleBuilder.prototype;\n\n  _proto.because = function because(reason) {\n    this.rule.reason = reason;\n    return this;\n  };\n\n  return RuleBuilder;\n}();\n\nvar AbilityBuilder =\n/*#__PURE__*/\nfunction () {\n  AbilityBuilder.define = function define(params, dsl) {\n    var options = typeof params === 'function' ? {} : params;\n    var define = params === options ? dsl : params;\n    var builder = new this(options);\n    var result = define(builder.can.bind(builder), builder.cannot.bind(builder));\n\n    var buildAbility = function buildAbility() {\n      return new Ability(builder.rules, options);\n    };\n\n    return result && typeof result.then === 'function' ? result.then(buildAbility) : buildAbility();\n  };\n\n  AbilityBuilder.extract = function extract() {\n    var builder = new this();\n    return {\n      can: builder.can.bind(builder),\n      cannot: builder.cannot.bind(builder),\n      rules: builder.rules\n    };\n  };\n\n  function AbilityBuilder(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$subjectName = _ref.subjectName,\n        subjectName = _ref$subjectName === void 0 ? getSubjectName : _ref$subjectName;\n\n    this.rules = [];\n    this.subjectName = subjectName;\n  }\n\n  var _proto2 = AbilityBuilder.prototype;\n\n  _proto2.can = function can(actions, subject, conditionsOrFields, conditions) {\n    if (!isStringOrNonEmptyArray(actions)) {\n      throw new TypeError('AbilityBuilder#can expects the first parameter to be an action or array of actions');\n    }\n\n    var subjectName = [].concat(subject).map(this.subjectName);\n\n    if (!isStringOrNonEmptyArray(subjectName)) {\n      throw new TypeError('AbilityBuilder#can expects the second argument to be a subject name/type or an array of subject names/types');\n    }\n\n    var rule = {\n      actions: actions,\n      subject: subjectName\n    };\n\n    if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n      rule.fields = conditionsOrFields;\n    }\n\n    if (isObject(conditions) || !rule.fields && isObject(conditionsOrFields)) {\n      rule.conditions = conditions || conditionsOrFields;\n    }\n\n    this.rules.push(rule);\n    return new RuleBuilder(rule);\n  };\n\n  _proto2.cannot = function cannot() {\n    var builder = this.can.apply(this, arguments);\n    builder.rule.inverted = true;\n    return builder;\n  };\n\n  return AbilityBuilder;\n}();\n\nexport { Ability, AbilityBuilder, ForbiddenError, Rule, RuleBuilder };","map":null,"metadata":{},"sourceType":"module"}