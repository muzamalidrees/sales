{"ast":null,"code":"/*\n *\n * Copryright 2018, Craig Condon\n * Licensed under MIT\n *\n * Filter JavaScript objects with mongodb queries\n */\n\n/**\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n */\n\n\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) === '[object Array]';\n}\n/**\n */\n\n\nfunction comparable(value) {\n  if (value instanceof Date) {\n    return value.getTime();\n  } else if (isArray(value)) {\n    return value.map(comparable);\n  } else if (value && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  } else {\n    return value;\n  }\n}\n\nfunction get(obj, key) {\n  return isFunction(obj.get) ? obj.get(key) : obj[key];\n}\n/**\n */\n\n\nfunction or(validator) {\n  return function (a, b) {\n    if (!isArray(b) || !b.length) {\n      return validator(a, b);\n    }\n\n    for (var i = 0, n = b.length; i < n; i++) {\n      if (validator(a, get(b, i))) return true;\n    }\n\n    return false;\n  };\n}\n/**\n */\n\n\nfunction and(validator) {\n  return function (a, b) {\n    if (!isArray(b) || !b.length) {\n      return validator(a, b);\n    }\n\n    for (var i = 0, n = b.length; i < n; i++) {\n      if (!validator(a, get(b, i))) return false;\n    }\n\n    return true;\n  };\n}\n\nfunction validate(validator, b, k, o) {\n  return validator.v(validator.a, b, k, o);\n}\n\nvar OPERATORS = {\n  /**\n   */\n  $eq: or(function (a, b) {\n    return a(b);\n  }),\n\n  /**\n   */\n  $ne: and(function (a, b) {\n    return !a(b);\n  }),\n\n  /**\n   */\n  $gt: or(function (a, b) {\n    return compare(comparable(b), a) > 0;\n  }),\n\n  /**\n   */\n  $gte: or(function (a, b) {\n    return compare(comparable(b), a) >= 0;\n  }),\n\n  /**\n   */\n  $lt: or(function (a, b) {\n    return compare(comparable(b), a) < 0;\n  }),\n\n  /**\n   */\n  $lte: or(function (a, b) {\n    return compare(comparable(b), a) <= 0;\n  }),\n\n  /**\n   */\n  $mod: or(function (a, b) {\n    return b % a[0] == a[1];\n  }),\n\n  /**\n   */\n  $in: function $in(a, b) {\n    if (b instanceof Array) {\n      for (var i = b.length; i--;) {\n        if (~a.indexOf(comparable(get(b, i)))) {\n          return true;\n        }\n      }\n    } else {\n      var comparableB = comparable(b);\n\n      if (comparableB === b && typeof b === 'object') {\n        for (var i = a.length; i--;) {\n          if (String(a[i]) === String(b) && String(b) !== '[object Object]') {\n            return true;\n          }\n        }\n      }\n      /*\n        Handles documents that are undefined, whilst also\n        having a 'null' element in the parameters to $in.\n      */\n\n\n      if (typeof comparableB == 'undefined') {\n        for (var i = a.length; i--;) {\n          if (a[i] == null) {\n            return true;\n          }\n        }\n      }\n      /*\n        Handles the case of {'field': {$in: [/regexp1/, /regexp2/, ...]}}\n      */\n\n\n      for (var i = a.length; i--;) {\n        var validator = createRootValidator(get(a, i), undefined);\n        var result = validate(validator, b, i, a);\n\n        if (result && String(result) !== '[object Object]' && String(b) !== '[object Object]') {\n          return true;\n        }\n      }\n\n      return !!~a.indexOf(comparableB);\n    }\n\n    return false;\n  },\n\n  /**\n   */\n  $nin: function $nin(a, b, k, o) {\n    return !OPERATORS.$in(a, b, k, o);\n  },\n\n  /**\n   */\n  $not: function $not(a, b, k, o) {\n    return !validate(a, b, k, o);\n  },\n\n  /**\n   */\n  $type: function $type(a, b) {\n    return b != void 0 ? b instanceof a || b.constructor == a : false;\n  },\n\n  /**\n   */\n  $all: function $all(a, b, k, o) {\n    return OPERATORS.$and(a, b, k, o);\n  },\n\n  /**\n   */\n  $size: function $size(a, b) {\n    return b ? a === b.length : false;\n  },\n\n  /**\n   */\n  $or: function $or(a, b, k, o) {\n    for (var i = 0, n = a.length; i < n; i++) {\n      if (validate(get(a, i), b, k, o)) return true;\n    }\n\n    return false;\n  },\n\n  /**\n   */\n  $nor: function $nor(a, b, k, o) {\n    return !OPERATORS.$or(a, b, k, o);\n  },\n\n  /**\n   */\n  $and: function $and(a, b, k, o) {\n    for (var i = 0, n = a.length; i < n; i++) {\n      if (!validate(get(a, i), b, k, o)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   */\n  $regex: or(function (a, b) {\n    return typeof b === 'string' && a.test(b);\n  }),\n\n  /**\n   */\n  $where: function $where(a, b, k, o) {\n    return a.call(b, b, k, o);\n  },\n\n  /**\n   */\n  $elemMatch: function $elemMatch(a, b, k, o) {\n    if (isArray(b)) {\n      return !!~search(b, a);\n    }\n\n    return validate(a, b, k, o);\n  },\n\n  /**\n   */\n  $exists: function $exists(a, b, k, o) {\n    return o.hasOwnProperty(k) === a;\n  }\n};\n/**\n */\n\nvar prepare = {\n  /**\n   */\n  $eq: function $eq(a) {\n    if (a instanceof RegExp) {\n      return function (b) {\n        return typeof b === 'string' && a.test(b);\n      };\n    } else if (a instanceof Function) {\n      return a;\n    } else if (isArray(a) && !a.length) {\n      // Special case of a == []\n      return function (b) {\n        return isArray(b) && !b.length;\n      };\n    } else if (a === null) {\n      return function (b) {\n        //will match both null and undefined\n        return b == null;\n      };\n    }\n\n    return function (b) {\n      return compare(comparable(b), comparable(a)) === 0;\n    };\n  },\n\n  /**\n   */\n  $ne: function $ne(a) {\n    return prepare.$eq(a);\n  },\n\n  /**\n   */\n  $and: function $and(a) {\n    return a.map(parse);\n  },\n\n  /**\n   */\n  $all: function $all(a) {\n    return prepare.$and(a);\n  },\n\n  /**\n   */\n  $or: function $or(a) {\n    return a.map(parse);\n  },\n\n  /**\n   */\n  $nor: function $nor(a) {\n    return a.map(parse);\n  },\n\n  /**\n   */\n  $not: function $not(a) {\n    return parse(a);\n  },\n\n  /**\n   */\n  $regex: function $regex(a, query) {\n    return new RegExp(a, query.$options);\n  },\n\n  /**\n   */\n  $where: function $where(a) {\n    return typeof a === 'string' ? new Function('obj', 'return ' + a) : a;\n  },\n\n  /**\n   */\n  $elemMatch: function $elemMatch(a) {\n    return parse(a);\n  },\n\n  /**\n   */\n  $exists: function $exists(a) {\n    return !!a;\n  }\n};\n/**\n */\n\nfunction search(array, validator) {\n  for (var i = 0; i < array.length; i++) {\n    var result = get(array, i);\n\n    if (validate(validator, get(array, i))) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n */\n\n\nfunction createValidator(a, validate) {\n  return {\n    a: a,\n    v: validate\n  };\n}\n/**\n */\n\n\nfunction nestedValidator(a, b) {\n  var values = [];\n  findValues(b, a.k, 0, b, values);\n\n  if (values.length === 1) {\n    var first = values[0];\n    return validate(a.nv, first[0], first[1], first[2]);\n  } // If the query contains $ne, need to test all elements ANDed together\n\n\n  var inclusive = a && a.q && typeof a.q.$ne !== 'undefined';\n  var allValid = inclusive;\n\n  for (var i = 0; i < values.length; i++) {\n    var result = values[i];\n    var isValid = validate(a.nv, result[0], result[1], result[2]);\n\n    if (inclusive) {\n      allValid &= isValid;\n    } else {\n      allValid |= isValid;\n    }\n  }\n\n  return allValid;\n}\n/**\n */\n\n\nfunction findValues(current, keypath, index, object, values) {\n  if (index === keypath.length || current == void 0) {\n    values.push([current, keypath[index - 1], object]);\n    return;\n  }\n\n  var k = get(keypath, index); // ensure that if current is an array, that the current key\n  // is NOT an array index. This sort of thing needs to work:\n  // sift({'foo.0':42}, [{foo: [42]}]);\n\n  if (isArray(current) && isNaN(Number(k))) {\n    for (var i = 0, n = current.length; i < n; i++) {\n      findValues(get(current, i), keypath, index, current, values);\n    }\n  } else {\n    findValues(get(current, k), keypath, index + 1, current, values);\n  }\n}\n/**\n */\n\n\nfunction createNestedValidator(keypath, a, q) {\n  return {\n    a: {\n      k: keypath,\n      nv: a,\n      q: q\n    },\n    v: nestedValidator\n  };\n}\n/**\n * flatten the query\n */\n\n\nfunction isVanillaObject(value) {\n  return value && value.constructor === Object;\n}\n\nfunction parse(query) {\n  query = comparable(query);\n\n  if (!query || !isVanillaObject(query)) {\n    // cross browser support\n    query = {\n      $eq: query\n    };\n  }\n\n  var validators = [];\n\n  for (var key in query) {\n    var a = query[key];\n\n    if (key === '$options') {\n      continue;\n    }\n\n    if (OPERATORS[key]) {\n      if (prepare[key]) a = prepare[key](a, query);\n      validators.push(createValidator(comparable(a), OPERATORS[key]));\n    } else {\n      if (key.charCodeAt(0) === 36) {\n        throw new Error('Unknown operation ' + key);\n      }\n\n      validators.push(createNestedValidator(key.split('.'), parse(a), a));\n    }\n  }\n\n  return validators.length === 1 ? validators[0] : createValidator(validators, OPERATORS.$and);\n}\n/**\n */\n\n\nfunction createRootValidator(query, getter) {\n  var validator = parse(query);\n\n  if (getter) {\n    validator = {\n      a: validator,\n      v: function v(a, b, k, o) {\n        return validate(a, getter(b), k, o);\n      }\n    };\n  }\n\n  return validator;\n}\n/**\n */\n\n\nexport default function sift(query, array, getter) {\n  if (isFunction(array)) {\n    getter = array;\n    array = void 0;\n  }\n\n  var validator = createRootValidator(query, getter);\n\n  function filter(b, k, o) {\n    return validate(validator, b, k, o);\n  }\n\n  if (array) {\n    return array.filter(filter);\n  }\n\n  return filter;\n}\n/**\n */\n\nexport function indexOf(query, array, getter) {\n  return search(array, createRootValidator(query, getter));\n}\n;\n/**\n */\n\nexport function compare(a, b) {\n  if (a === b) return 0;\n\n  if (typeof a === typeof b) {\n    if (a > b) {\n      return 1;\n    }\n\n    if (a < b) {\n      return -1;\n    }\n  }\n}\n;","map":null,"metadata":{},"sourceType":"module"}